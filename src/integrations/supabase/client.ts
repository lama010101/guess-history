// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';

const SUPABASE_URL = "https://jghesmrwhegaotbztrhr.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImpnaGVzbXJ3aGVnYW90Ynp0cmhyIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDQ0MzAwMDEsImV4cCI6MjA2MDAwNjAwMX0.C-zSGAiZAIbvKh9vNb2_s3DHogSzSKImLkRbjr_h5xI";

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

// Intercept fetch to strip redirect_to from signup if present (to avoid 500s when redirect isn't whitelisted)
const originalFetch = window.fetch.bind(window);
const interceptFetch: typeof fetch = async (input: RequestInfo | URL, init?: RequestInit) => {
  try {
    const makeRequest = (urlStr: string) => originalFetch(urlStr, init);
    if (typeof input === 'string') {
      if (input.includes('/auth/v1/signup') && input.includes('redirect_to=')) {
        const url = new URL(input);
        url.searchParams.delete('redirect_to');
        console.debug('[supabase] Stripped redirect_to from signup request (string URL)');
        return makeRequest(url.toString());
      }
      return originalFetch(input, init);
    }
    if (input instanceof URL) {
      if (input.toString().includes('/auth/v1/signup') && input.searchParams.has('redirect_to')) {
        const url = new URL(input.toString());
        url.searchParams.delete('redirect_to');
        console.debug('[supabase] Stripped redirect_to from signup request (URL instance)');
        return makeRequest(url.toString());
      }
      return originalFetch(input, init);
    }
    // Request object case
    const req = input as Request;
    const href = req.url;
    if (href.includes('/auth/v1/signup') && href.includes('redirect_to=')) {
      const url = new URL(href);
      url.searchParams.delete('redirect_to');
      console.debug('[supabase] Stripped redirect_to from signup request (Request object)');
      return originalFetch(url.toString(), init ?? { method: req.method, headers: req.headers });
    }
    return originalFetch(input, init);
  } catch (e) {
    // Fallback to original if anything goes wrong
    return originalFetch(input as any, init);
  }
};

// Force global override to catch any internal usage
try {
  // Only override in browser contexts and ensure we only intercept once across HMR
  if (
    typeof window !== 'undefined' &&
    typeof window.fetch === 'function' &&
    !(window as any).__supabaseFetchIntercepted
  ) {
    window.fetch = interceptFetch as any;
    (window as any).__supabaseFetchIntercepted = true;
  }
} catch {
  // ignore
}

const isStandalonePWA = () => {
  try {
    if (typeof window === 'undefined') return false;
    if (window.matchMedia?.('(display-mode: standalone)')?.matches) return true;
    return (window.navigator as any)?.standalone === true;
  } catch {
    return false;
  }
};

const resolveAuthStorage = () => {
  try {
    if (isStandalonePWA()) {
      return { store: localStorage, persist: true } as const;
    }

    const rememberSession = sessionStorage.getItem('auth.remember') === 'false';
    if (rememberSession) {
      return { store: sessionStorage, persist: false } as const;
    }

    const rememberValue = localStorage.getItem('auth.remember');
    const persist = rememberValue === null ? true : rememberValue === 'true';
    return { store: persist ? localStorage : sessionStorage, persist } as const;
  } catch {
    return { store: localStorage, persist: true } as const;
  }
};

const clientOptions = {
  auth: {
    persistSession: true,
    autoRefreshToken: true,
    detectSessionInUrl: true,
    storageKey: 'supabase.auth.token',
    storage: {
      getItem: (key: string) => {
        try {
          const { store } = resolveAuthStorage();
          return store.getItem(key);
        } catch {
          return localStorage.getItem(key);
        }
      },
      setItem: (key: string, value: string) => {
        try {
          const { store, persist } = resolveAuthStorage();
          store.setItem(key, value);
          if (persist) {
            try { localStorage.setItem('auth.remember', 'true'); } catch {}
          }
          // Cross-subdomain cookie: persistent if remembered, session-only otherwise
          const base = `${key}=${value};domain=.guess-history.com;path=/;secure;samesite=lax`;
          document.cookie = persist ? `${base};max-age=${60 * 60 * 24 * 7}` : base;
        } catch {
          localStorage.setItem(key, value);
          document.cookie = `${key}=${value};domain=.guess-history.com;path=/;max-age=${60 * 60 * 24 * 7};secure;samesite=lax`;
        }
      },
      removeItem: (key: string) => {
        try {
          // Remove from both to be safe
          localStorage.removeItem(key);
          sessionStorage.removeItem(key);
          // Remove cookie by setting expiry in the past
          document.cookie = `${key}=;domain=.guess-history.com;path=/;max-age=0;secure;samesite=lax`;
        } catch {
          localStorage.removeItem(key);
          document.cookie = `${key}=;domain=.guess-history.com;path=/;max-age=0;secure;samesite=lax`;
        }
      }
    }
  },
  global: {
    fetch: interceptFetch,
  }
} as const;

// Create or reuse a singleton Supabase client across HMR reloads
const g: any = (globalThis as any);
export const supabase = (g.__supabaseClient ||= createClient<Database>(
  SUPABASE_URL,
  SUPABASE_PUBLISHABLE_KEY,
  clientOptions as any
));

export default supabase;